/**************************************************************************

Filename    :   GFxKoreanIME.cpp
Content     :   Core implementation of Korean IME
Created     :   Feb 27, 2008
Authors     :   A. Mohan, A. Bolgar

Copyright   :   Copyright 2011 Autodesk, Inc. All Rights reserved.

Use of this software is subject to the terms of the Autodesk license
agreement provided at the time of installation or download, or which
otherwise accompanies this software in either electronic or hard copy form.

**************************************************************************/
#ifndef UNICODE
#define UNICODE //necessary for IME functions
#endif //UNICODE
#include "Kernel/SF_Types.h"

#if defined(SF_OS_WIN32) && defined(GFX_ENABLE_BUILTIN_KOREAN_IME) && !defined(SF_NO_IME_SUPPORT)
#include "GFx/GFx_PlayerImpl.h"
# pragma warning(disable : 4005)
#define ReplaceText ReplaceTextA
#include "GFx/GFx_TextField.h"
# pragma warning(default : 4005)
#include "GFxIMEImm32Dll.h"

namespace Scaleform { namespace GFx {

unsigned MovieImpl::HandleKoreanIME(const IMEEvent& imeEvent)
{
    // check if Imm32.dll is available.
    if (!Imm32Dll.IsAvailable())
    {
        UInt32 errorCode;
        if ((errorCode = Imm32Dll.GetErrorCode()) != 0)
        {
            Log* plog = GetLog();
            if (plog)
                plog->LogError("IMM32.DLL is not available, error code = 0x%X", errorCode);
            Imm32Dll.ResetErrorCode(); 
        }
		return MovieImpl::HE_NotHandled; // no Imm32 is available, aborting....
    }

    const IMEWin32Event& winEvt = static_cast<const IMEWin32Event&>(imeEvent);
    if (winEvt.IMEEvtType != IMEEvent::IME_PreProcessKeyboard)
    {
        HWND hWND = (HWND)winEvt.hWND;
        union {
            HKL     hkl;
            UPInt   langId;
        } un;
        un.hkl = GetKeyboardLayout(0); 
        if ((un.langId & 0xFFFF) == MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN)) //korean
        {
            //printf("!!! %X\n", un.langId);
            switch(winEvt.Message)
            {
            case WM_IME_STARTCOMPOSITION:
                {
                    Ptr<InteractiveObject> pfocusedCh = GetFocusedCharacter(0);
					if (pfocusedCh && pfocusedCh->GetType() == TextFieldDef::TextField)
					{
						Ptr<TextField> ptextFld = static_cast<TextField*>(pfocusedCh.GetPtr());
                        if (ptextFld->IsIMEEnabled())
                        {
                            // first of all, if we have an active selection - remove it

							ptextFld->ReplaceText(L"", ptextFld->GetBeginIndex(), 
                                ptextFld->GetEndIndex());

                            ptextFld->CreateCompositionString();
                            //ptextFld->SetCompositionStringHighlighting(true);
                        }
                    }
                    return MovieImpl::HE_NoDefaultAction;
                }

            case WM_IME_COMPOSITION:
                {
					Ptr<InteractiveObject> pfocusedCh = GetFocusedCharacter(0);
					if (pfocusedCh && pfocusedCh->GetType() == TextFieldDef::TextField)
					{
						Ptr<TextField> ptextFld = static_cast<TextField*>(pfocusedCh.GetPtr());
						if (ptextFld->IsIMEEnabled())
						{
                            UPInt keyCode = winEvt.WParam, info = winEvt.LParam;
                            //int options = winEvt.Options;
                            if (info & GCS_RESULTSTR) 
                            {
                                HIMC hIMC = Imm32Dll.ImmGetContext(hWND);
                                // Get the size of the result string.
                                DWORD dwSize = Imm32Dll.ImmGetCompositionString(hIMC, GCS_RESULTSTR, NULL, 0);
                                wchar_t lpstr[20]; // very unlikely, Korean composition string is longer than 20 chars 
                                                   // (or even, longer than 2 chars). Anyway we have an ASSERT to 
                                                   // catch any weird situations.
                                SF_ASSERT(sizeof(lpstr) >= (dwSize+sizeof(wchar_t)));

                                // Get the result string that is generated by IME into lpstr.
                                LONG res = Imm32Dll.ImmGetCompositionString(hIMC, GCS_RESULTSTR, lpstr, dwSize);
                                if (res != IMM_ERROR_NODATA && res != IMM_ERROR_GENERAL)
                                {
                                    lpstr[dwSize/2] = 0; //dwSize is in bytes
                                    ptextFld->SetWideCursor(false);
                                }

                                Imm32Dll.ImmReleaseContext(hWND, hIMC);
                                ptextFld->CommitCompositionString(lpstr, SF_MAX_UPINT);
                                //ptextFld->SetCompositionStringHighlighting(true, SF_MAX_UPINT);
                            }
                            if ((info & CS_INSERTCHAR) && (info & CS_NOMOVECARET) )
                            {
                                // This is for Korean- a character can change shape depending upon what is typed next, 
                                // so don't advance caret position. Move Caret when the character is finalized.
                                // The "replace" flag is used to indicate whether we should replace the current character 
                                // or not-In case of korean, when the user begins to type, the character should be 
                                // inserted at the current location, but subsequent modifications to the same character 
                                // should replace the existing character.
                                wchar_t lpstr[2];
                                lpstr[0] = (wchar_t)keyCode; lpstr[1] = 0;
 
                                ptextFld->SetWideCursor(true);

                                UPInt pos = ptextFld->GetCaretIndex();
                                ptextFld->SetCompositionStringPosition(pos);
                                ptextFld->SetCompositionStringText(lpstr, 1);
                                ptextFld->SetCursorInCompositionString(0);
                            }
                        }
                    }
                    return MovieImpl::HE_NoDefaultAction;
                }

            case WM_IME_ENDCOMPOSITION:
                {
					Ptr<InteractiveObject> pfocusedCh = GetFocusedCharacter(0);
					if (pfocusedCh && pfocusedCh->GetType() == TextFieldDef::TextField)
					{
						Ptr<TextField> ptextFld = static_cast<TextField*>(pfocusedCh.GetPtr());
						if (ptextFld->IsIMEEnabled())
						{
                            ptextFld->SetWideCursor(false);
                            ptextFld->ClearCompositionString();
                        }
                    }
                    return MovieImpl::HE_NoDefaultAction;
                }
            case WM_IME_CHAR:
                // This message should not be passed down to DefWinProc otherwise it will
                // generate WM_CHAR messages which will cause text duplication.
                return MovieImpl::HE_NoDefaultAction;
            }
        }
    }
    return MovieImpl::HE_NotHandled;
}
}}

#endif // SF_NO_BUILTIN_KOREAN_IME
